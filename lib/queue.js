// Generated by CoffeeScript 1.12.1
(function() {
  var Job, Queue, Rabbot, _;

  _ = require('lodash');

  Rabbot = require('rabbot');

  Job = require('./job');

  module.exports = Queue = (function() {
    function Queue(name1, options, connection) {
      this.name = name1;
      this.connection = connection;
      this.log = this.connection.log;
      this.stats = this.connection.stats;
      this.options = _.defaultsDeep(options, {
        name: this.name,
        type: this.connection.exchange.name + '.' + this.name,
        timeout: null,
        concurrency: 1,
        id: 0
      });
      this.lastPublish = 0;
      this.lastComplete = 0;
    }

    Queue.prototype.connect = function(cb) {
      var concurrency, name, ref, type;
      ref = this.options, name = ref.name, type = ref.type, concurrency = ref.concurrency;
      Rabbot.handle({
        queue: type,
        type: type,
        autoNack: true,
        handler: this.processJob,
        context: this
      });
      return Rabbot.addQueue(type, {
        subscribe: true,
        autoDelete: false,
        durable: true,
        limit: concurrency
      }).then((function(_this) {
        return function() {
          Rabbot.bindQueue(_this.connection.exchange.name, type, [type]);
          _this.log.info({
            type: type,
            concurrency: concurrency
          }, "RabbitMQ Queue Started");
          setInterval((function() {
            if (_this.lastPublish) {
              _this.stats('timing', type, 'lag', Math.abs(_this.lastPublish - _this.lastComplete));
              return _this.lastPublish = 0;
            }
          }), 60 * 1000);
          return cb(null, _this);
        };
      })(this))["catch"](function(err) {
        return cb("Could not initialise queue: " + err.stack, this);
      });
    };

    Queue.prototype.createJob = function(body, options) {
      return new Job(this.options.type, body, options, this);
    };

    Queue.prototype.publish = function(body, options, cb) {
      var job;
      job = new Job(this.options.type, this);
      return job.publish(body, options, cb);
    };

    Queue.prototype.request = function(body, options, cb) {
      var job;
      job = new Job(this.options.type, this);
      return job.request(body, options, cb);
    };

    Queue.prototype.processJob = function(message) {
      var job;
      job = new Job(this.options.type, this);
      return job.process(message);
    };

    Queue.prototype.partFailure = function(message) {
      var base, base1;
      if (typeof (base = this.options).partFailure === "function") {
        base.partFailure(message);
      }
      return typeof (base1 = this.connection).partFailure === "function" ? base1.partFailure(message) : void 0;
    };

    Queue.prototype.fullFailure = function(message) {
      var base, base1;
      if (typeof (base = this.options).fullFailure === "function") {
        base.fullFailure(message);
      }
      return typeof (base1 = this.connection).fullFailure === "function" ? base1.fullFailure(message) : void 0;
    };

    return Queue;

  })();

}).call(this);

//# sourceMappingURL=queue.js.map
